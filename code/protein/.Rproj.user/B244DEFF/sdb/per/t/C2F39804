{
    "contents" : "# RPPA classification\n# ieuan.clay@gmail.com\n# April 2015\n\n### set up session\n## packages\nlibrary(stats)\n\n## global vars\n# https://tcga-data.nci.nih.gov/docs/publications/TCGApancan_2014/\nINPUT <- \"https://tcga-data.nci.nih.gov/docs/publications/TCGApancan_2014/RPPA_input.csv\"\nOUTPUT <- \"https://tcga-data.nci.nih.gov/docs/publications/TCGApancan_2014/RPPA_output.csv\"\n\n# holder for results\nRESULTS <- list()\nTIMES <- list()\n\n# reproducibility\nset.seed(8008)\n\n### functions\ndo.load <- function(csv){\n  ## load data\n  \n  # samples x features matrix, including some sample metadata\n  rppa <- read.csv(csv, header=T, stringsAsFactors=F)\n  \n  # drop non-numeric columns\n  rows <- rppa$TCGA_ID\n  rppa <- rppa[, sapply(rppa, is.numeric)]\n  row.names(rppa) <- rows\n  \n  # check it\n  # str(rppa)\n  # dim(rppa) # 3467  131\n  \n  return(rppa)\n}\n\n### classification\n## original description of method here: http://www.cell.com/cms/attachment/2019543870/2039643570/mmc1.pdf\n# Unsupervised Clustering: \n#  - unsupervised clustering\n#  - Pearson correlation was used as the distance metric\n#  - Ward was used as the linkage algorithm\n#  - We identified eight robust clusters\n#  - The input data matrix for RPPA clustering is available in Synapse at syn1759392 and the subtype assignments are at syn1756922.\n\ndo.dist <- function(input_data){\n  ## compute distance matrix\n  \n  # transpose input data to get distances between samples, not features\n  # convert pearson correlation to distance (i.e. bound 0-1, 0 is close)\n  dist_mat <- as.dist((1-cor(t(input_data), method=\"pearson\"))/2)\n  \n  return(dist_mat)\n}\n\n## unsupervised clustering\ndo.within.ss <- function(d = NULL, clustering){\n  # cut from 'fpc' package function cluster.stats()\n  #   a generalisation of the within clusters sum of squares \n  #   (k-means objective function), which is obtained if d is a Euclidean \n  #   distance matrix. For general distance measures, this is half the sum of the \n  #   within cluster squared dissimilarities divided by the cluster size.\n  \n  # variables\n  cluster.size <- numeric(0)\n  dmat <- as.matrix(d)\n  within.cluster.ss <- 0\n  di <- list()\n  \n  # iterate thought distance matrix\n  for (i in 1:max(clustering)) {\n    cluster.size[i] <- sum(clustering == i)\n    di <- as.dist(dmat[clustering == i, clustering == i])\n    if (i <= max(clustering)) {\n      within.cluster.ss <- within.cluster.ss + sum(di^2)/cluster.size[i]\n      \n    }\n    \n  }\n  \n  return(within.cluster.ss)\n  \n}\n# hierarchical\ndo.hc <- function(dist_mat){\n  ptm <- proc.time()\n  \n  require(stats)\n  \n  # hierarchical clustering, WARD as linkage\n  res <- hclust(d = dist_mat, method=\"ward.D2\")\n  \n  TIMES$hc.clust <<- proc.time() - ptm\n  \n  # determine optimal clustering using within cluster SS, for a range of 'cuts'\n  ptm <- proc.time() # reset clock\n  cuts <- lapply(2:25, FUN = function(i){ # note: 1 cluster => 'Inf' error\n    \n      cluster.stats(dist_mat, cutree(res, k=i))\n    }  \n  )\n  \n  TIMES$hc.cut <<- proc.time() - ptm\n  # determine optimal cut and return labels\n  # TODO: use within cluster SS to be consistent with kmeans?\n  best_cut <- 8 # according to paper\n  res <- cutree(res, best_cut)\n  res <- data.frame(id=attr(dist_mat, which = \"Labels\"), cluster=res)\n\n  return(res)\n}\n\n# kmeans\ndo.km <- function(dist_mat){\n  ptm <- proc.time()\n  \n  require(stats)\n  \n  # kmeans clustering for a range of cluster numbers\n  res <- lapply(2:25, FUN = function(i){\n      kmeans(dist_mat, algorithm=\"Hartigan-Wong\", centers=i)\n    }\n  )\n  TIMES$km.clust <<- proc.time() - ptm\n  \n  # determine optimal clustering using cluster.stats, for a range of 'cuts'\n  ptm <- proc.time() # reset\n  cuts <- lapply(res, function(x){sum(x$withinss)})\n  TIMES$km.cut <<- proc.time() - ptm\n  \n  # TODO: determine optimal cut and return labels for this\n  best_cut <- 8 # according to paper\n  res <- res[best_cut]\n  res <- data.frame(id=attr(dist_mat, which = \"Labels\"), cluster=res$cluster)\n  \n  return(res)\n}\n\n# random forrest\ndo.rf <- function(dist_mat){\n  # TBD\n}\n\n# bayesian\ndo.bayes <- function(dist_mat){\n # TBD  \n}\n\n### reporting\n## load data and compute matrix\nTIMES$load <- system.time(gcFirst = T,\n  rppa <- do.load(csv=INPUT)\n)\nTIMES$dist <- system.time(gcFirst = T,\n  dist_mat <- do.dist(input_data=rppa)\n)\n## clustering\n# hierarchical\nTIMES$hc <- system.time(gcFirst = T,\n  RESULTS$hc <- do.hc(dist_mat=dist_mat)\n)\n# kmeans\nTIMES$km <- system.time(gcFirst = T,\n  RESULTS$km <- do.km(dist_mat=dist_mat)\n)\n\n# random forrest\n\n# bayes\n\n### compare results to each other and to published\n# collect published results\nRESULTS$pub <- read.csv(OUTPUT, header = TRUE, stringsAsFactors=FALSE)\nnames(RESULTS$pub) <- c(\"id\", \"cluster\")\n# replace dots with dashes in names to make comparible to names given in input\nRESULTS$pub$id <-\n  unlist(lapply(strsplit(\n    # split on dots\n    RESULTS$pub$id, split = \"\\\\.\", perl=T), \n    # rejoin with dashes\n    function(x) paste(x,collapse=\"-\"))\n  )\n\n# compare stability of number of clusters or membership to expected results\n# TBD\n\n# output results for comparison\n# todo: redirect to given file or similar\nwrite.table(file=\"\", quote = FALSE, sep = \"\\t\", row.names = FALSE, col.names = TRUE,\n  do.call(\"rbind\", \n          lapply(names(RESULTS), function(x){\n            cbind(RESULTS[[x]], data.frame(res=x))\n              }\n            )\n          )\n  )\n\n# timings\n# todo: redirect to file or other\nwrite.table(file=\"\", quote = FALSE, sep = \"\\t\", row.names = TRUE, col.names = TRUE,\n  format(do.call(\"rbind\", TIMES), digits=5)\n)\n",
    "created" : 1428655244143.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4223007694",
    "id" : "C2F39804",
    "lastKnownWriteTime" : 1428677691,
    "path" : "C:/Users/Ieuan and Katharina/ieuan_work/bdd/genbase/code/protein/rppa.R",
    "project_path" : "rppa.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "source_on_save" : false,
    "type" : "r_source"
}